"var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},h=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!f.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(a=m(e,r))||a.enumerable});return t};var b=(t,e,i)=>(i=t!=null?p(g(t)):{},h(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),x=t=>h(o({},\"__esModule\",{value:!0}),t);var l=w((D,c)=>{c.exports=_jsx_runtime});var v={};y(v,{default:()=>d});var n=b(l());function s(t){let e={a:\"a\",code:\"code\",h3:\"h3\",h4:\"h4\",img:\"img\",li:\"li\",p:\"p\",pre:\"pre\",ul:\"ul\",...t.components},{Callout:i}=e;return i||k(\"Callout\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[`Getting images right and fast on the web is hard.\nIf we are doing it wrong,\nwe create a poor user experience with slow loading times and\nCLS (`,(0,n.jsx)(e.a,{href:\"https://blog.hubspot.com/marketing/cumulative-layout-shift#:~:text=What%20is%20Cumulative%20Layout%20Shift,constitute%20a%20large%20CLS%20score.\",children:\"Cumulative Layout Shift\"}),\").\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"next/image\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The result of \",(0,n.jsx)(e.code,{children:\"[1, 2, 3].join('-'){:js}\"}),\" is \",(0,n.jsx)(e.code,{children:\"'1-2-3'{:js}\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In \",(0,n.jsx)(e.a,{href:\"https://nextjs.org/\",children:\"Next.js\"}),\" we can use the \",(0,n.jsx)(e.a,{href:\"https://nextjs.org/docs/api-reference/next/image\",children:\"next/image\"}),` component to avoid this bad user experience.\n`,(0,n.jsx)(e.code,{children:\"next/image\"}),\" automatically optimizes our images in three ways to reduce the slow loading times:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Converts the image to the smallest supported format\"}),`\n`,(0,n.jsx)(e.li,{children:\"Resizes the image based on the used device viewport\"}),`\n`,(0,n.jsx)(e.li,{children:\"Uses image compression\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[`It also creates a placeholder to avoid the CLS.\nThe following example shows the usage of `,(0,n.jsx)(e.code,{children:\"next/image\"}),\" with a static image:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`import picture from './pictures/mountain.jpg'\n;<Image src={picture} alt=\"Picture of a mountain\" placeholder=\"blur\" />\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Markdown\"}),`\n`,(0,n.jsx)(e.p,{children:\"This looks great, but how can we use it in our markdown files?\"}),`\n`,(0,n.jsx)(e.h3,{children:\"MDX\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"My first reaction was to use \",(0,n.jsx)(e.a,{href:\"https://mdxjs.com/\",children:\"MDX\"}),\" and use \",(0,n.jsx)(e.code,{children:\"next/image\"}),` just as in the example.\nBut that means that we can't use normal markdown images and\nit turns out that this won't work with `,(0,n.jsx)(e.a,{href:\"https://www.contentlayer.dev/\",children:\"contentlayer\"}),`.\nIt won't work, because `,(0,n.jsx)(e.a,{href:\"https://nextjs.org/\",children:\"Next.js\"}),` does some magic on the import of the static image.\nThe object which gets returned by the import\ncontains not only a path to the image,\nit contains also the width and height\nplus a very small version of the image for the blurred placeholder.\nThis magic does not work if the `,(0,n.jsx)(e.a,{href:\"https://mdxjs.com/\",children:\"MDX\"}),\" file is loaded with \",(0,n.jsx)(e.a,{href:\"https://www.contentlayer.dev/\",children:\"contentlayer\"}),`,\nbecause `,(0,n.jsx)(e.a,{href:\"https://www.contentlayer.dev/\",children:\"contentlayer\"}),` uses its own bundler,\nwhich knows nothing about the import magic for images.`]}),`\n`,(0,n.jsx)(e.h3,{children:\"The trick with the public folder\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The next idea was to use normal markdown images and to place the images in the \",(0,n.jsx)(e.code,{children:\"public\"}),` folder.\nThis eliminates the need for static imports and treats our image like a remote image.\nBut in order to make this work, we have to tell `,(0,n.jsx)(e.code,{children:\"next/image\"}),` the dimensions of the image.\nIf we would use a static import for the image,\nthe import magic would provide the dimensions for us.\nTo pass the width and height to the image component we use a `,(0,n.jsx)(e.a,{href:\"https://github.com/rehypejs/rehype\",children:\"rehype\"}),\" plugin called \",(0,n.jsx)(e.a,{href:\"https://github.com/ksoichiro/rehype-img-size\",children:\"rehype-img-size\"}),\".\"]}),`\n`,(0,n.jsx)(e.img,{src:\"/contentlayer-next-image/process.jpg\",alt:\"pussy\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`pnpm add -D rehype-img-size\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"After installation we can configure \",(0,n.jsx)(e.a,{href:\"https://www.contentlayer.dev/\",children:\"contentlayer\"}),\" to use the plugin within \",(0,n.jsx)(e.a,{href:\"https://mdxjs.com/\",children:\"MDX\"}),`,\nbut it should work with `,(0,n.jsx)(e.a,{href:\"https://www.contentlayer.dev/docs/reference/source-files/make-source#markdown\",children:\"markdown\"}),\" too.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`export default makeSource({\n  contentDirPath: 'content/posts',\n  documentTypes: [Post],\n  mdx: {\n    rehypePlugins: [[rehypeImgSize, { dir: 'public' }]],\n    remarkPlugins: [],\n  },\n})\n`})}),`\n`,(0,n.jsx)(e.p,{children:`The plugin will now find each image in the markdown content and pass its dimensions to the image component.\nIf we have the following markdown content...`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-markdown\",children:`![Picture of a mountain](/pictures/mountain.jpg)\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"... \",(0,n.jsx)(e.a,{href:\"https://github.com/ksoichiro/rehype-img-size\",children:\"rehype-img-size\"}),` will look up\n`,(0,n.jsx)(e.code,{children:\"pictures/mountain.jpg\"}),\" in the \",(0,n.jsx)(e.code,{children:\"public\"}),` directory (as configured in the contentlayer config) and\ncalculate its size.\nNow we can replace the image component with `,(0,n.jsx)(e.code,{children:\"next/image\"}),\":\"]}),`\n`,(0,n.jsx)(\"a\",{id:\"replace-img-with-next-image\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`import { useMDXComponent } from 'next-contentlayer/hooks'\nimport Image from 'next/image'\n\ntype Props = {\n  code: string\n}\n\nconst Markdown = ({ code }: Props) => {\n  const MDXComponent = useMDXComponent(code)\n  return (\n    <MDXComponent\n      components={{\n        img: Image,\n      }}\n    />\n  )\n}\n\nexport default Markdown\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"And that's it, we are now using \",(0,n.jsx)(e.code,{children:\"next/image\"}),` to render our markdown images.\nThis approach works, but it is not ideal, because the images can't be located next to the content.\nThey have to be placed in the `,(0,n.jsx)(e.code,{children:\"public\"}),\" directory.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"It would be better if we could locate the images right next to the content:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`\\u{1F4C1} content/posts/2022-12-11-sample\n\\u2502\n\\u2514\\u2500\\u2500 \\u{1F4C1} assets\n    \\u2502\n    \\u2514\\u2500\\u2500 \\u{1F4C4} mountaindick.jpg\n    \\u2502\n    \\u2514\\u2500\\u2500 \\u{1F4C4} index.mdx\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[`We also don't have the small image for the blurred placeholder,\nwe can only use the `,(0,n.jsx)(e.code,{children:\"empty\"}),\" placeholder.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"If these two things are not so important to you, this is the right approach.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Custom rehype plugin\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To fix the two weaknesses from the last approach, we can write a custom \",(0,n.jsx)(e.a,{href:\"https://github.com/rehypejs/rehype\",children:\"rehype\"}),` plugin.\nOur plugin should do the following things:`]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Copy the image from its location to the public folder\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update the \",(0,n.jsx)(e.code,{children:\"src\"}),\" attribute to the new location\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Calculate the width and height\"}),`\n`,(0,n.jsx)(e.li,{children:\"Create small image for blurred placeholder\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[`Before we write this plugin,\nwe should understand how the markdown processing works in `,(0,n.jsx)(e.a,{href:\"https://www.contentlayer.dev/\",children:\"contentlayer\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://www.contentlayer.dev/\",children:\"contentlayer\"}),\" uses \",(0,n.jsx)(e.a,{href:\"https://github.com/remarkjs/remark\",children:\"remark\"}),\" to parse the markdown into a \",(0,n.jsx)(e.a,{href:\"https://github.com/syntax-tree/mdast\",children:\"mdast\"}),`.\nWe can now use `,(0,n.jsx)(e.code,{children:\"remark plugins\"}),\" to modify the \",(0,n.jsx)(e.code,{children:\"mdast\"}),`.\nThen `,(0,n.jsx)(e.code,{children:\"rehype\"}),\" comes into play and converts the \",(0,n.jsx)(e.code,{children:\"mdast\"}),\" into a \",(0,n.jsx)(e.a,{href:\"https://github.com/syntax-tree/hast\",children:\"hast\"}),`.\n`,(0,n.jsx)(e.code,{children:\"rehype plugins\"}),\" can now modify the \",(0,n.jsx)(e.code,{children:\"hast\"}),`.\nFinally the `,(0,n.jsx)(e.code,{children:\"hast\"}),\" is converted into \",(0,n.jsx)(e.a,{href:\"https://reactjs.org/\",children:\"react\"}),\" components.\"]}),`\n`,(0,n.jsx)(e.img,{src:\"/contentlayer-next-image/markdown.avif\",alt:\"markdown processing\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"For our plugin we have to modify the \",(0,n.jsx)(e.code,{children:\"hast\"}),`,\nbecause images in the `,(0,n.jsx)(e.code,{children:\"mdast\"}),` don't have width or height and they don't support custom properties.\nThe `,(0,n.jsx)(e.code,{children:\"hast\"}),\" on the other hand supports all properties of the HTML \",(0,n.jsx)(e.code,{children:\"img\"}),` component and\nwe can pass custom properties.`]}),`\n`,(0,n.jsx)(e.h4,{children:\"Implementation\"}),`\n`,(0,n.jsx)(e.p,{children:\"We start our plugin by defining the options:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"publicDir: path to the public directory\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:`Then we can define our plugin.\nThe plugin is a function which gets the options and returns another function which receives the following parameters:`}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"tree: the whole \",(0,n.jsx)(e.code,{children:\"hast\"})]}),`\n`,(0,n.jsx)(e.li,{children:\"file: the parsed file with path and content\"}),`\n`,(0,n.jsx)(e.li,{children:\"done: a function which should be called when our plugin has finished\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Our plugin searches the \",(0,n.jsx)(e.code,{children:\"hast\"}),\" tree and for each element with the \",(0,n.jsx)(e.code,{children:\"tagName\"}),\" \",(0,n.jsx)(e.code,{children:\"img\"}),`\nwe call the `,(0,n.jsx)(e.code,{children:\"processImage\"}),` function.\n`,(0,n.jsx)(e.code,{children:\"rehype\"}),` plugins can't be async, but image processing is async.\nThat's the reason why we store each resulting `,(0,n.jsx)(e.code,{children:\"Promise\"}),\" of the \",(0,n.jsx)(e.code,{children:\"processImage\"}),` function in an array and\ncall the `,(0,n.jsx)(e.code,{children:\"done\"}),\" function if all \",(0,n.jsx)(e.code,{children:\"Promises\"}),\" are resolved and the work is done.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`type Options = {\n  publicDir: string\n}\n\nconst staticImages: Plugin<[Options], Root> =\n  (options) => (tree, file, done) => {\n    const tasks: Promise<void>[] = []\n\n    visit(tree, 'element', (node) => {\n      if (node.tagName === 'img') {\n        tasks.push(processImage(options, file, node))\n      }\n    })\n\n    Promise.all(tasks).then(() => done())\n  }\n\nconst processImage = async (\n  options: Options,\n  file: VFileWithOutput<unknown>,\n  Element\n): Promise<void> => {\n  // implementation comes next\n}\n\nexport default staticImages\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Ok, now we can have a detailed look at the implementation of the \",(0,n.jsx)(e.code,{children:\"processImage\"}),` function.\nAt first we have to find the real path of the image.\nFortunately, contentlayer stores information about the location of our markdown file in the `,(0,n.jsx)(e.code,{children:\"data\"}),\" field of the \",(0,n.jsx)(e.code,{children:\"file\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`// find the content directory\nconst root = file.dirname || process.cwd()\n\n// find the directory of the markdown file\n// RawDocumentData is an import from contentlayer/source-files\nconst data = file.data as { rawDocumentData: RawDocumentData }\nconst directory = data.rawDocumentData.sourceFileDir\n\n// get the path of the image from the src attributes\nconst filePath = (image.properties?.src as string) || ''\n\n// create the path by joining root, directory and filePath\n// path is imported from path\nconst imagePath = path.join(root, directory, filePath)\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now that we have the path we can use \",(0,n.jsx)(e.a,{href:\"https://sharp.pixelplumbing.com/\",children:\"sharp\"}),\" to read the width and height of the image.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`// sharp is an import from sharp (@types/sharp)\nconst image = await sharp(imagePath)\n\n// get the width and height of the image\nconst { width, height } = await image.metadata()\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[`After that we can create a small version of the image for the blurred placeholder.\nWe will create a `,(0,n.jsx)(e.code,{children:\"png\"}),\" with a \",(0,n.jsx)(e.code,{children:\"quality\"}),\" of \",(0,n.jsx)(e.code,{children:\"75\"}),\", a width of \",(0,n.jsx)(e.code,{children:\"8px\"}),\" and we keep the aspect ratio.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`const imgAspectRatio = width / height\nconst blurDataURL = await image\n  .resize(8, Math.round(8 / imgAspectRatio))\n  .png({\n    quality: 75,\n  })\n  .toBuffer()\n  .then((buffer) => \\`data:image/png;base64,\\${buffer.toString('base64')}\\`)\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Then we can copy the image to the \",(0,n.jsx)(e.code,{children:\"public\"}),\" folder and create a new path for the \",(0,n.jsx)(e.code,{children:\"src\"}),\" attribute of the image.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`const src = path.join(directory, filePath)\nconst target = path.join(options.publicDir, src)\n\nawait fs.mkdir(path.dirname(targetDir), { recursive: true })\nawait fs.copyFile(imagePath, target)\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"With all the information in place we can update the properties of the \",(0,n.jsx)(e.code,{children:\"img\"}),\" tag.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`node.properties = {\n  ...node.properties,\n  width,\n  height,\n  src: path.join('/', src),\n  blurDataURL,\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"After we have finished writing our plugin, it is time to configure contentlayer.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import mdxImages from './lib/static-images'\n\nexport default makeSource({\n  contentDirPath: 'content/posts',\n  documentTypes: [Post],\n  mdx: {\n    rehypePlugins: [\n      [mdxImages, { publicDir: path.join(process.cwd(), 'public') }],\n    ],\n    remarkPlugins: [],\n  },\n})\n`})}),`\n`,(0,n.jsx)(i,{emoji:\"\\u26A0\\uFE0F\",children:(0,n.jsxs)(e.p,{children:[\"Don't forget to replace the \",(0,n.jsx)(e.code,{children:\"img\"}),\" tag with \",(0,n.jsx)(e.code,{children:\"next/image\"}),`.\nAs we have seen in the `,(0,n.jsx)(\"a\",{href:\"#replace-img-with-next-image\",children:\"rehype-img-size method\"}),\".\"]})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`fn fib(n: u64) -> u64 {\n  if n <= 1 {\n    return n;\n  }\n  fib(n - 1) + fib(n - 2)\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Conclusion\"}),`\n`,(0,n.jsx)(e.p,{children:\"Ok, let's summarize again what we have achieved.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We have written a \",(0,n.jsx)(e.code,{children:\"rehype\"}),\" plugin, which does the following steps fully automatic for us:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Copy the image from its location to the public folder\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update the \",(0,n.jsx)(e.code,{children:\"src\"}),\" attribute to the new location\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Calculate the width and height\"}),`\n`,(0,n.jsx)(e.li,{children:\"Create a small image for the blurred placeholder\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"With this plugin we can use the normal markdown image syntax and gain all the benefits of \",(0,n.jsx)(e.code,{children:\"next/image\"}),\":\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Smallest supported format\"}),`\n`,(0,n.jsx)(e.li,{children:\"Resized version based on the used device viewport\"}),`\n`,(0,n.jsx)(e.li,{children:\"image compression\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"For a more complete example have a look at the \",(0,n.jsx)(e.a,{href:\"https://github.com/sdorra/sdorra.dev/blob/main/lib/static-images.ts\",children:\"article's source code\"}),\".\"]})]})}function d(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(s,{...t})}):s(t)}function k(t,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+t+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return x(v);})();\n;return Component;"